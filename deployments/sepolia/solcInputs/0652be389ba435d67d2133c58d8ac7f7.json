{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "contracts/modules/019-marketplace/IMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/**\r\n * @title IMarketplace\r\n * @notice Interface for the Campus Marketplace — a full-featured e-commerce\r\n *         platform for students and teachers to buy/sell products & services.\r\n *         Inspired by Shopee / TikTok Shop functionality.\r\n */\r\ninterface IMarketplace {\r\n    // ─── Enums ───\r\n    enum ProductStatus { Active, SoldOut, Paused, Deleted }\r\n    enum OrderStatus   { Pending, Confirmed, Shipping, Delivered, Completed, Cancelled, Refunded, Disputed }\r\n    enum ShopStatus    { Active, Suspended, Closed }\r\n\r\n    // ─── Events: Shop ───\r\n    event ShopRegistered(address indexed owner, uint256 indexed shopId, string shopName, uint256 timestamp);\r\n    event ShopUpdated(address indexed owner, uint256 indexed shopId, uint256 timestamp);\r\n    event ShopSuspended(uint256 indexed shopId, string reason, uint256 timestamp);\r\n    event ShopReactivated(uint256 indexed shopId, uint256 timestamp);\r\n\r\n    // ─── Events: Product ───\r\n    event ProductListed(uint256 indexed productId, uint256 indexed shopId, string name, uint256 price, uint256 timestamp);\r\n    event ProductUpdated(uint256 indexed productId, uint256 timestamp);\r\n    event ProductStatusChanged(uint256 indexed productId, ProductStatus newStatus, uint256 timestamp);\r\n\r\n    // ─── Events: Order ───\r\n    event OrderCreated(uint256 indexed orderId, address indexed buyer, uint256 indexed shopId, uint256 totalAmount, uint256 timestamp);\r\n    event OrderStatusUpdated(uint256 indexed orderId, OrderStatus newStatus, uint256 timestamp);\r\n    event OrderRefunded(uint256 indexed orderId, uint256 amount, string reason, uint256 timestamp);\r\n\r\n    // ─── Events: Review / Wishlist / Cart ───\r\n    event ReviewSubmitted(uint256 indexed productId, address indexed reviewer, uint256 rating, uint256 timestamp);\r\n    event ProductAddedToWishlist(address indexed user, uint256 indexed productId, uint256 timestamp);\r\n    event ProductRemovedFromWishlist(address indexed user, uint256 indexed productId, uint256 timestamp);\r\n    event DisputeOpened(uint256 indexed orderId, address indexed opener, string reason, uint256 timestamp);\r\n    event DisputeResolved(uint256 indexed orderId, string resolution, uint256 timestamp);\r\n\r\n    // ─── Shop Management ───\r\n    function registerShop(string calldata shopName, string calldata description, string calldata avatarURI, string calldata category) external returns (uint256 shopId);\r\n    function updateShop(uint256 shopId, string calldata shopName, string calldata description, string calldata avatarURI, string calldata category) external;\r\n    function getShopInfo(uint256 shopId) external view returns (\r\n        address owner, string memory shopName, string memory description,\r\n        string memory avatarURI, string memory category,\r\n        ShopStatus status, uint256 totalProducts, uint256 totalSales,\r\n        uint256 totalRevenue, uint256 totalRating, uint256 reviewCount,\r\n        uint256 createdAt\r\n    );\r\n    function getShopsByOwner(address owner) external view returns (uint256[] memory);\r\n    function getTotalShops() external view returns (uint256);\r\n    function suspendShop(uint256 shopId, string calldata reason) external;\r\n    function reactivateShop(uint256 shopId) external;\r\n    function getShopProducts(uint256 shopId) external view returns (uint256[] memory);\r\n\r\n    // ─── Product Management ───\r\n    function listProduct(\r\n        uint256 shopId, string calldata name, string calldata description,\r\n        uint256 price, uint256 stock, string calldata category,\r\n        string calldata imageURI, string calldata condition\r\n    ) external returns (uint256 productId);\r\n    function updateProduct(\r\n        uint256 productId, string calldata name, string calldata description,\r\n        uint256 price, uint256 stock, string calldata category,\r\n        string calldata imageURI\r\n    ) external;\r\n    function changeProductStatus(uint256 productId, ProductStatus newStatus) external;\r\n    function getProduct(uint256 productId) external view returns (\r\n        uint256 id, uint256 shopId, string memory name, string memory description,\r\n        uint256 price, uint256 stock, uint256 sold,\r\n        string memory category, string memory imageURI, string memory condition,\r\n        ProductStatus status, uint256 totalRating, uint256 reviewCount,\r\n        uint256 createdAt\r\n    );\r\n    function getTotalProducts() external view returns (uint256);\r\n    function getProductsByCategory(string calldata category) external view returns (uint256[] memory);\r\n    function searchProducts(string calldata keyword) external view returns (uint256[] memory);\r\n\r\n    // ─── Order Management ───\r\n    function createOrder(uint256[] calldata productIds, uint256[] calldata quantities, string calldata shippingAddress, string calldata note) external returns (uint256 orderId);\r\n    function confirmOrder(uint256 orderId) external;\r\n    function shipOrder(uint256 orderId, string calldata trackingCode) external;\r\n    function confirmDelivery(uint256 orderId) external;\r\n    function completeOrder(uint256 orderId) external;\r\n    function cancelOrder(uint256 orderId, string calldata reason) external;\r\n    function requestRefund(uint256 orderId, string calldata reason) external;\r\n    function approveRefund(uint256 orderId) external;\r\n    function getOrder(uint256 orderId) external view returns (\r\n        uint256 id, address buyer, uint256 shopId,\r\n        uint256 totalAmount, string memory shippingAddress,\r\n        string memory note, string memory trackingCode,\r\n        OrderStatus status, uint256 createdAt, uint256 updatedAt\r\n    );\r\n    function getOrderItems(uint256 orderId) external view returns (uint256[] memory productIds, uint256[] memory quantities, uint256[] memory prices);\r\n    function getBuyerOrders(address buyer) external view returns (uint256[] memory);\r\n    function getShopOrders(uint256 shopId) external view returns (uint256[] memory);\r\n    function getTotalOrders() external view returns (uint256);\r\n\r\n    // ─── Reviews & Ratings ───\r\n    function submitReview(uint256 productId, uint256 orderId, uint256 rating, string calldata comment, string calldata imageURI) external;\r\n    function getProductReviews(uint256 productId) external view returns (\r\n        address[] memory reviewers, uint256[] memory ratings,\r\n        string[] memory comments, string[] memory imageURIs,\r\n        uint256[] memory timestamps\r\n    );\r\n\r\n    // ─── Wishlist / Favorites ───\r\n    function addToWishlist(uint256 productId) external;\r\n    function removeFromWishlist(uint256 productId) external;\r\n    function getWishlist(address user) external view returns (uint256[] memory);\r\n\r\n    // ─── Cart (on-chain for persistence) ───\r\n    function addToCart(uint256 productId, uint256 quantity) external;\r\n    function removeFromCart(uint256 productId) external;\r\n    function updateCartQuantity(uint256 productId, uint256 quantity) external;\r\n    function getCart(address user) external view returns (uint256[] memory productIds, uint256[] memory quantities);\r\n    function clearCart() external;\r\n\r\n    // ─── Disputes ───\r\n    function openDispute(uint256 orderId, string calldata reason) external;\r\n    function resolveDispute(uint256 orderId, string calldata resolution, bool refundBuyer) external;\r\n\r\n    // ─── Platform Stats ───\r\n    function getPlatformStats() external view returns (\r\n        uint256 totalShops, uint256 totalProducts,\r\n        uint256 totalOrders, uint256 totalVolume,\r\n        uint256 totalReviews\r\n    );\r\n}\r\n"
    },
    "contracts/modules/019-marketplace/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"./IMarketplace.sol\";\r\n\r\n/**\r\n * @title Marketplace\r\n * @author VNDC Education Platform\r\n * @notice Full-featured campus e-commerce marketplace for students & teachers\r\n *         Product listing, ordering, reviews, wishlist, cart, disputes.\r\n * @dev Module 019 – follows platform conventions (counters start at 1, Ownable)\r\n */\r\ncontract Marketplace is IMarketplace, Ownable, ReentrancyGuard {\r\n\r\n    // ─── Counters ───\r\n    uint256 public nextShopId;\r\n    uint256 public nextProductId;\r\n    uint256 public nextOrderId;\r\n\r\n    // ─── Platform fee (basis points, 100 = 1%) ───\r\n    uint256 public platformFeeBps;\r\n    address public feeRecipient;\r\n    uint256 public totalPlatformVolume;\r\n    uint256 public totalPlatformReviews;\r\n\r\n    // ─── Structs ───\r\n    struct Shop {\r\n        address owner;\r\n        string  shopName;\r\n        string  description;\r\n        string  avatarURI;\r\n        string  category;\r\n        ShopStatus status;\r\n        uint256 totalProducts;\r\n        uint256 totalSales;\r\n        uint256 totalRevenue;\r\n        uint256 totalRating;\r\n        uint256 reviewCount;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    struct Product {\r\n        uint256 id;\r\n        uint256 shopId;\r\n        string  name;\r\n        string  description;\r\n        uint256 price;\r\n        uint256 stock;\r\n        uint256 sold;\r\n        string  category;\r\n        string  imageURI;\r\n        string  condition;\r\n        ProductStatus status;\r\n        uint256 totalRating;\r\n        uint256 reviewCount;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    struct Order {\r\n        uint256 id;\r\n        address buyer;\r\n        uint256 shopId;\r\n        uint256 totalAmount;\r\n        string  shippingAddress;\r\n        string  note;\r\n        string  trackingCode;\r\n        OrderStatus status;\r\n        uint256 createdAt;\r\n        uint256 updatedAt;\r\n    }\r\n\r\n    struct OrderItem {\r\n        uint256 productId;\r\n        uint256 quantity;\r\n        uint256 price;\r\n    }\r\n\r\n    struct Review {\r\n        address reviewer;\r\n        uint256 rating;\r\n        string  comment;\r\n        string  imageURI;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct CartItem {\r\n        uint256 productId;\r\n        uint256 quantity;\r\n    }\r\n\r\n    struct Dispute {\r\n        uint256 orderId;\r\n        address opener;\r\n        string  reason;\r\n        string  resolution;\r\n        bool    resolved;\r\n        uint256 openedAt;\r\n        uint256 resolvedAt;\r\n    }\r\n\r\n    // ─── Storage ───\r\n    mapping(uint256 => Shop)      public shops;\r\n    mapping(uint256 => Product)   public products;\r\n    mapping(uint256 => Order)     public orders;\r\n\r\n    // Shop helpers\r\n    mapping(address => uint256[]) private _ownerShops;\r\n    mapping(uint256 => uint256[]) private _shopProductIds;\r\n    mapping(uint256 => uint256[]) private _shopOrderIds;\r\n\r\n    // Order items\r\n    mapping(uint256 => OrderItem[]) private _orderItems;\r\n\r\n    // Buyer orders\r\n    mapping(address => uint256[]) private _buyerOrders;\r\n\r\n    // Reviews\r\n    mapping(uint256 => Review[]) private _productReviews;\r\n    mapping(bytes32 => bool)     private _hasReviewed; // keccak256(buyer,productId,orderId)\r\n\r\n    // Wishlist\r\n    mapping(address => uint256[])          private _wishlist;\r\n    mapping(address => mapping(uint256 => bool)) private _inWishlist;\r\n\r\n    // Cart\r\n    mapping(address => CartItem[])          private _cart;\r\n    mapping(address => mapping(uint256 => uint256)) private _cartIndex; // productId => index+1\r\n\r\n    // Category index\r\n    mapping(string => uint256[]) private _categoryProducts;\r\n\r\n    // Disputes\r\n    mapping(uint256 => Dispute) public disputes;\r\n\r\n    // ─── Constructor ───\r\n    constructor() Ownable(msg.sender) {\r\n        nextShopId    = 1;\r\n        nextProductId = 1;\r\n        nextOrderId   = 1;\r\n        platformFeeBps = 250; // 2.5 %\r\n        feeRecipient  = msg.sender;\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Admin ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function setPlatformFee(uint256 _feeBps) external onlyOwner {\r\n        require(_feeBps <= 1000, \"Fee too high\"); // max 10%\r\n        platformFeeBps = _feeBps;\r\n    }\r\n\r\n    function setFeeRecipient(address _recipient) external onlyOwner {\r\n        require(_recipient != address(0), \"Zero address\");\r\n        feeRecipient = _recipient;\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Shop Management ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function registerShop(\r\n        string calldata shopName,\r\n        string calldata description,\r\n        string calldata avatarURI,\r\n        string calldata category\r\n    ) external returns (uint256 shopId) {\r\n        require(bytes(shopName).length > 0, \"Empty name\");\r\n\r\n        shopId = nextShopId++;\r\n        Shop storage s = shops[shopId];\r\n        s.owner       = msg.sender;\r\n        s.shopName    = shopName;\r\n        s.description = description;\r\n        s.avatarURI   = avatarURI;\r\n        s.category    = category;\r\n        s.status      = ShopStatus.Active;\r\n        s.createdAt   = block.timestamp;\r\n\r\n        _ownerShops[msg.sender].push(shopId);\r\n\r\n        emit ShopRegistered(msg.sender, shopId, shopName, block.timestamp);\r\n    }\r\n\r\n    function updateShop(\r\n        uint256 shopId,\r\n        string calldata shopName,\r\n        string calldata description,\r\n        string calldata avatarURI,\r\n        string calldata category\r\n    ) external {\r\n        Shop storage s = shops[shopId];\r\n        require(s.owner == msg.sender, \"Not shop owner\");\r\n        require(s.status != ShopStatus.Closed, \"Shop closed\");\r\n\r\n        s.shopName    = shopName;\r\n        s.description = description;\r\n        s.avatarURI   = avatarURI;\r\n        s.category    = category;\r\n\r\n        emit ShopUpdated(msg.sender, shopId, block.timestamp);\r\n    }\r\n\r\n    function suspendShop(uint256 shopId, string calldata reason) external onlyOwner {\r\n        Shop storage s = shops[shopId];\r\n        require(s.status == ShopStatus.Active, \"Not active\");\r\n        s.status = ShopStatus.Suspended;\r\n        emit ShopSuspended(shopId, reason, block.timestamp);\r\n    }\r\n\r\n    function reactivateShop(uint256 shopId) external onlyOwner {\r\n        Shop storage s = shops[shopId];\r\n        require(s.status == ShopStatus.Suspended, \"Not suspended\");\r\n        s.status = ShopStatus.Active;\r\n        emit ShopReactivated(shopId, block.timestamp);\r\n    }\r\n\r\n    function getShopInfo(uint256 shopId) external view returns (\r\n        address owner_, string memory shopName_, string memory description_,\r\n        string memory avatarURI_, string memory category_,\r\n        ShopStatus status_, uint256 totalProducts_, uint256 totalSales_,\r\n        uint256 totalRevenue_, uint256 totalRating_, uint256 reviewCount_,\r\n        uint256 createdAt_\r\n    ) {\r\n        Shop storage s = shops[shopId];\r\n        return (\r\n            s.owner, s.shopName, s.description,\r\n            s.avatarURI, s.category,\r\n            s.status, s.totalProducts, s.totalSales,\r\n            s.totalRevenue, s.totalRating, s.reviewCount,\r\n            s.createdAt\r\n        );\r\n    }\r\n\r\n    function getShopsByOwner(address owner) external view returns (uint256[] memory) {\r\n        return _ownerShops[owner];\r\n    }\r\n\r\n    function getTotalShops() external view returns (uint256) {\r\n        return nextShopId - 1;\r\n    }\r\n\r\n    function getShopProducts(uint256 shopId) external view returns (uint256[] memory) {\r\n        return _shopProductIds[shopId];\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Product Management ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function listProduct(\r\n        uint256 shopId,\r\n        string calldata name,\r\n        string calldata description,\r\n        uint256 price,\r\n        uint256 stock,\r\n        string calldata category,\r\n        string calldata imageURI,\r\n        string calldata condition\r\n    ) external returns (uint256 productId) {\r\n        Shop storage s = shops[shopId];\r\n        require(s.owner == msg.sender, \"Not shop owner\");\r\n        require(s.status == ShopStatus.Active, \"Shop not active\");\r\n        require(price > 0, \"Price must be > 0\");\r\n        require(bytes(name).length > 0, \"Empty name\");\r\n\r\n        productId = nextProductId++;\r\n        Product storage p = products[productId];\r\n        p.id          = productId;\r\n        p.shopId      = shopId;\r\n        p.name        = name;\r\n        p.description = description;\r\n        p.price       = price;\r\n        p.stock       = stock;\r\n        p.category    = category;\r\n        p.imageURI    = imageURI;\r\n        p.condition   = condition;\r\n        p.status      = stock > 0 ? ProductStatus.Active : ProductStatus.SoldOut;\r\n        p.createdAt   = block.timestamp;\r\n\r\n        s.totalProducts++;\r\n        _shopProductIds[shopId].push(productId);\r\n        _categoryProducts[category].push(productId);\r\n\r\n        emit ProductListed(productId, shopId, name, price, block.timestamp);\r\n    }\r\n\r\n    function updateProduct(\r\n        uint256 productId,\r\n        string calldata name,\r\n        string calldata description,\r\n        uint256 price,\r\n        uint256 stock,\r\n        string calldata category,\r\n        string calldata imageURI\r\n    ) external {\r\n        Product storage p = products[productId];\r\n        require(shops[p.shopId].owner == msg.sender, \"Not owner\");\r\n        require(p.status != ProductStatus.Deleted, \"Deleted\");\r\n\r\n        p.name        = name;\r\n        p.description = description;\r\n        p.price       = price;\r\n        p.stock       = stock;\r\n        p.category    = category;\r\n        p.imageURI    = imageURI;\r\n\r\n        if (stock == 0 && p.status == ProductStatus.Active) {\r\n            p.status = ProductStatus.SoldOut;\r\n        } else if (stock > 0 && p.status == ProductStatus.SoldOut) {\r\n            p.status = ProductStatus.Active;\r\n        }\r\n\r\n        emit ProductUpdated(productId, block.timestamp);\r\n    }\r\n\r\n    function changeProductStatus(uint256 productId, ProductStatus newStatus) external {\r\n        Product storage p = products[productId];\r\n        require(shops[p.shopId].owner == msg.sender || owner() == msg.sender, \"Not authorized\");\r\n        p.status = newStatus;\r\n        emit ProductStatusChanged(productId, newStatus, block.timestamp);\r\n    }\r\n\r\n    function getProduct(uint256 productId) external view returns (\r\n        uint256 id_, uint256 shopId_, string memory name_, string memory description_,\r\n        uint256 price_, uint256 stock_, uint256 sold_,\r\n        string memory category_, string memory imageURI_, string memory condition_,\r\n        ProductStatus status_, uint256 totalRating_, uint256 reviewCount_,\r\n        uint256 createdAt_\r\n    ) {\r\n        Product storage p = products[productId];\r\n        return (\r\n            p.id, p.shopId, p.name, p.description,\r\n            p.price, p.stock, p.sold,\r\n            p.category, p.imageURI, p.condition,\r\n            p.status, p.totalRating, p.reviewCount,\r\n            p.createdAt\r\n        );\r\n    }\r\n\r\n    function getTotalProducts() external view returns (uint256) {\r\n        return nextProductId - 1;\r\n    }\r\n\r\n    function getProductsByCategory(string calldata category) external view returns (uint256[] memory) {\r\n        return _categoryProducts[category];\r\n    }\r\n\r\n    function searchProducts(string calldata /* keyword */) external view returns (uint256[] memory) {\r\n        // On-chain full-text search is expensive; return all active products\r\n        // FE should handle client-side filtering based on keyword\r\n        uint256 total = nextProductId - 1;\r\n        uint256 count;\r\n        for (uint256 i = 1; i <= total; i++) {\r\n            if (products[i].status == ProductStatus.Active) count++;\r\n        }\r\n        uint256[] memory result = new uint256[](count);\r\n        uint256 idx;\r\n        for (uint256 i = 1; i <= total; i++) {\r\n            if (products[i].status == ProductStatus.Active) {\r\n                result[idx++] = i;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Order Management ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function createOrder(\r\n        uint256[] calldata productIds,\r\n        uint256[] calldata quantities,\r\n        string calldata shippingAddress,\r\n        string calldata note\r\n    ) external nonReentrant returns (uint256 orderId) {\r\n        require(productIds.length > 0, \"Empty order\");\r\n        require(productIds.length == quantities.length, \"Length mismatch\");\r\n\r\n        // All products must belong to same shop\r\n        uint256 shopId = products[productIds[0]].shopId;\r\n        uint256 totalAmount;\r\n\r\n        for (uint256 i = 0; i < productIds.length; i++) {\r\n            Product storage p = products[productIds[i]];\r\n            require(p.shopId == shopId, \"Multi-shop order not supported\");\r\n            require(p.status == ProductStatus.Active, \"Product not active\");\r\n            require(p.stock >= quantities[i], \"Insufficient stock\");\r\n            require(quantities[i] > 0, \"Zero quantity\");\r\n\r\n            uint256 lineTotal = p.price * quantities[i];\r\n            totalAmount += lineTotal;\r\n\r\n            // Reserve stock\r\n            p.stock -= quantities[i];\r\n            if (p.stock == 0) {\r\n                p.status = ProductStatus.SoldOut;\r\n                emit ProductStatusChanged(productIds[i], ProductStatus.SoldOut, block.timestamp);\r\n            }\r\n        }\r\n\r\n        orderId = nextOrderId++;\r\n        Order storage o = orders[orderId];\r\n        o.id              = orderId;\r\n        o.buyer           = msg.sender;\r\n        o.shopId          = shopId;\r\n        o.totalAmount     = totalAmount;\r\n        o.shippingAddress = shippingAddress;\r\n        o.note            = note;\r\n        o.status          = OrderStatus.Pending;\r\n        o.createdAt       = block.timestamp;\r\n        o.updatedAt       = block.timestamp;\r\n\r\n        for (uint256 i = 0; i < productIds.length; i++) {\r\n            _orderItems[orderId].push(OrderItem({\r\n                productId: productIds[i],\r\n                quantity:  quantities[i],\r\n                price:     products[productIds[i]].price\r\n            }));\r\n        }\r\n\r\n        _buyerOrders[msg.sender].push(orderId);\r\n        _shopOrderIds[shopId].push(orderId);\r\n\r\n        emit OrderCreated(orderId, msg.sender, shopId, totalAmount, block.timestamp);\r\n    }\r\n\r\n    function confirmOrder(uint256 orderId) external {\r\n        Order storage o = orders[orderId];\r\n        require(shops[o.shopId].owner == msg.sender, \"Not shop owner\");\r\n        require(o.status == OrderStatus.Pending, \"Not pending\");\r\n        o.status    = OrderStatus.Confirmed;\r\n        o.updatedAt = block.timestamp;\r\n        emit OrderStatusUpdated(orderId, OrderStatus.Confirmed, block.timestamp);\r\n    }\r\n\r\n    function shipOrder(uint256 orderId, string calldata trackingCode) external {\r\n        Order storage o = orders[orderId];\r\n        require(shops[o.shopId].owner == msg.sender, \"Not shop owner\");\r\n        require(o.status == OrderStatus.Confirmed, \"Not confirmed\");\r\n        o.trackingCode = trackingCode;\r\n        o.status       = OrderStatus.Shipping;\r\n        o.updatedAt    = block.timestamp;\r\n        emit OrderStatusUpdated(orderId, OrderStatus.Shipping, block.timestamp);\r\n    }\r\n\r\n    function confirmDelivery(uint256 orderId) external {\r\n        Order storage o = orders[orderId];\r\n        require(o.buyer == msg.sender, \"Not buyer\");\r\n        require(o.status == OrderStatus.Shipping, \"Not shipping\");\r\n        o.status    = OrderStatus.Delivered;\r\n        o.updatedAt = block.timestamp;\r\n        emit OrderStatusUpdated(orderId, OrderStatus.Delivered, block.timestamp);\r\n    }\r\n\r\n    function completeOrder(uint256 orderId) external {\r\n        Order storage o = orders[orderId];\r\n        require(o.buyer == msg.sender || shops[o.shopId].owner == msg.sender, \"Not authorized\");\r\n        require(o.status == OrderStatus.Delivered, \"Not delivered\");\r\n        o.status    = OrderStatus.Completed;\r\n        o.updatedAt = block.timestamp;\r\n\r\n        // Update shop stats\r\n        Shop storage s = shops[o.shopId];\r\n        OrderItem[] storage items = _orderItems[orderId];\r\n        for (uint256 i = 0; i < items.length; i++) {\r\n            products[items[i].productId].sold += items[i].quantity;\r\n        }\r\n        s.totalSales++;\r\n        s.totalRevenue += o.totalAmount;\r\n        totalPlatformVolume += o.totalAmount;\r\n\r\n        emit OrderStatusUpdated(orderId, OrderStatus.Completed, block.timestamp);\r\n    }\r\n\r\n    function cancelOrder(uint256 orderId, string calldata /* reason */) external {\r\n        Order storage o = orders[orderId];\r\n        require(\r\n            o.buyer == msg.sender || shops[o.shopId].owner == msg.sender || owner() == msg.sender,\r\n            \"Not authorized\"\r\n        );\r\n        require(\r\n            o.status == OrderStatus.Pending || o.status == OrderStatus.Confirmed,\r\n            \"Cannot cancel\"\r\n        );\r\n\r\n        // Restore stock\r\n        OrderItem[] storage items = _orderItems[orderId];\r\n        for (uint256 i = 0; i < items.length; i++) {\r\n            Product storage p = products[items[i].productId];\r\n            p.stock += items[i].quantity;\r\n            if (p.status == ProductStatus.SoldOut && p.stock > 0) {\r\n                p.status = ProductStatus.Active;\r\n                emit ProductStatusChanged(items[i].productId, ProductStatus.Active, block.timestamp);\r\n            }\r\n        }\r\n\r\n        o.status    = OrderStatus.Cancelled;\r\n        o.updatedAt = block.timestamp;\r\n        emit OrderStatusUpdated(orderId, OrderStatus.Cancelled, block.timestamp);\r\n    }\r\n\r\n    function requestRefund(uint256 orderId, string calldata reason) external {\r\n        Order storage o = orders[orderId];\r\n        require(o.buyer == msg.sender, \"Not buyer\");\r\n        require(\r\n            o.status == OrderStatus.Confirmed ||\r\n            o.status == OrderStatus.Shipping  ||\r\n            o.status == OrderStatus.Delivered,\r\n            \"Cannot refund\"\r\n        );\r\n        // We use dispute mechanism for refund flow\r\n        _openDisputeInternal(orderId, msg.sender, reason);\r\n    }\r\n\r\n    function approveRefund(uint256 orderId) external {\r\n        Order storage o = orders[orderId];\r\n        require(shops[o.shopId].owner == msg.sender || owner() == msg.sender, \"Not authorized\");\r\n        require(o.status != OrderStatus.Refunded && o.status != OrderStatus.Cancelled, \"Already resolved\");\r\n\r\n        // Restore stock\r\n        OrderItem[] storage items = _orderItems[orderId];\r\n        for (uint256 i = 0; i < items.length; i++) {\r\n            Product storage p = products[items[i].productId];\r\n            p.stock += items[i].quantity;\r\n            if (p.status == ProductStatus.SoldOut && p.stock > 0) {\r\n                p.status = ProductStatus.Active;\r\n            }\r\n        }\r\n\r\n        o.status    = OrderStatus.Refunded;\r\n        o.updatedAt = block.timestamp;\r\n        emit OrderRefunded(orderId, o.totalAmount, \"Approved\", block.timestamp);\r\n    }\r\n\r\n    function getOrder(uint256 orderId) external view returns (\r\n        uint256 id_, address buyer_, uint256 shopId_,\r\n        uint256 totalAmount_, string memory shippingAddress_,\r\n        string memory note_, string memory trackingCode_,\r\n        OrderStatus status_, uint256 createdAt_, uint256 updatedAt_\r\n    ) {\r\n        Order storage o = orders[orderId];\r\n        return (\r\n            o.id, o.buyer, o.shopId,\r\n            o.totalAmount, o.shippingAddress,\r\n            o.note, o.trackingCode,\r\n            o.status, o.createdAt, o.updatedAt\r\n        );\r\n    }\r\n\r\n    function getOrderItems(uint256 orderId) external view returns (\r\n        uint256[] memory productIds_,\r\n        uint256[] memory quantities_,\r\n        uint256[] memory prices_\r\n    ) {\r\n        OrderItem[] storage items = _orderItems[orderId];\r\n        uint256 len = items.length;\r\n        productIds_ = new uint256[](len);\r\n        quantities_ = new uint256[](len);\r\n        prices_     = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            productIds_[i] = items[i].productId;\r\n            quantities_[i] = items[i].quantity;\r\n            prices_[i]     = items[i].price;\r\n        }\r\n    }\r\n\r\n    function getBuyerOrders(address buyer) external view returns (uint256[] memory) {\r\n        return _buyerOrders[buyer];\r\n    }\r\n\r\n    function getShopOrders(uint256 shopId) external view returns (uint256[] memory) {\r\n        return _shopOrderIds[shopId];\r\n    }\r\n\r\n    function getTotalOrders() external view returns (uint256) {\r\n        return nextOrderId - 1;\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Reviews & Ratings ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function submitReview(\r\n        uint256 productId,\r\n        uint256 orderId,\r\n        uint256 rating,\r\n        string calldata comment,\r\n        string calldata imageURI\r\n    ) external {\r\n        require(rating >= 1 && rating <= 5, \"Rating 1-5\");\r\n        Order storage o = orders[orderId];\r\n        require(o.buyer == msg.sender, \"Not buyer\");\r\n        require(o.status == OrderStatus.Completed || o.status == OrderStatus.Delivered, \"Not completed\");\r\n\r\n        bytes32 key = keccak256(abi.encodePacked(msg.sender, productId, orderId));\r\n        require(!_hasReviewed[key], \"Already reviewed\");\r\n        _hasReviewed[key] = true;\r\n\r\n        _productReviews[productId].push(Review({\r\n            reviewer:  msg.sender,\r\n            rating:    rating,\r\n            comment:   comment,\r\n            imageURI:  imageURI,\r\n            timestamp: block.timestamp\r\n        }));\r\n\r\n        Product storage p = products[productId];\r\n        p.totalRating += rating;\r\n        p.reviewCount++;\r\n\r\n        Shop storage s = shops[p.shopId];\r\n        s.totalRating += rating;\r\n        s.reviewCount++;\r\n        totalPlatformReviews++;\r\n\r\n        emit ReviewSubmitted(productId, msg.sender, rating, block.timestamp);\r\n    }\r\n\r\n    function getProductReviews(uint256 productId) external view returns (\r\n        address[] memory reviewers_,\r\n        uint256[] memory ratings_,\r\n        string[]  memory comments_,\r\n        string[]  memory imageURIs_,\r\n        uint256[] memory timestamps_\r\n    ) {\r\n        Review[] storage reviews = _productReviews[productId];\r\n        uint256 len = reviews.length;\r\n        reviewers_  = new address[](len);\r\n        ratings_    = new uint256[](len);\r\n        comments_   = new string[](len);\r\n        imageURIs_  = new string[](len);\r\n        timestamps_ = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            reviewers_[i]  = reviews[i].reviewer;\r\n            ratings_[i]    = reviews[i].rating;\r\n            comments_[i]   = reviews[i].comment;\r\n            imageURIs_[i]  = reviews[i].imageURI;\r\n            timestamps_[i] = reviews[i].timestamp;\r\n        }\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Wishlist / Favorites ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function addToWishlist(uint256 productId) external {\r\n        require(!_inWishlist[msg.sender][productId], \"Already in wishlist\");\r\n        require(products[productId].id != 0, \"Product not found\");\r\n        _inWishlist[msg.sender][productId] = true;\r\n        _wishlist[msg.sender].push(productId);\r\n        emit ProductAddedToWishlist(msg.sender, productId, block.timestamp);\r\n    }\r\n\r\n    function removeFromWishlist(uint256 productId) external {\r\n        require(_inWishlist[msg.sender][productId], \"Not in wishlist\");\r\n        _inWishlist[msg.sender][productId] = false;\r\n        // Remove from array\r\n        uint256[] storage list = _wishlist[msg.sender];\r\n        for (uint256 i = 0; i < list.length; i++) {\r\n            if (list[i] == productId) {\r\n                list[i] = list[list.length - 1];\r\n                list.pop();\r\n                break;\r\n            }\r\n        }\r\n        emit ProductRemovedFromWishlist(msg.sender, productId, block.timestamp);\r\n    }\r\n\r\n    function getWishlist(address user) external view returns (uint256[] memory) {\r\n        return _wishlist[user];\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Cart ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function addToCart(uint256 productId, uint256 quantity) external {\r\n        require(products[productId].id != 0, \"Product not found\");\r\n        require(quantity > 0, \"Zero quantity\");\r\n\r\n        uint256 idx = _cartIndex[msg.sender][productId];\r\n        if (idx > 0) {\r\n            _cart[msg.sender][idx - 1].quantity += quantity;\r\n        } else {\r\n            _cart[msg.sender].push(CartItem({productId: productId, quantity: quantity}));\r\n            _cartIndex[msg.sender][productId] = _cart[msg.sender].length; // 1-based\r\n        }\r\n    }\r\n\r\n    function removeFromCart(uint256 productId) external {\r\n        uint256 idx = _cartIndex[msg.sender][productId];\r\n        require(idx > 0, \"Not in cart\");\r\n        CartItem[] storage cart = _cart[msg.sender];\r\n        uint256 last = cart.length - 1;\r\n        if (idx - 1 != last) {\r\n            cart[idx - 1] = cart[last];\r\n            _cartIndex[msg.sender][cart[idx - 1].productId] = idx;\r\n        }\r\n        cart.pop();\r\n        delete _cartIndex[msg.sender][productId];\r\n    }\r\n\r\n    function updateCartQuantity(uint256 productId, uint256 quantity) external {\r\n        uint256 idx = _cartIndex[msg.sender][productId];\r\n        require(idx > 0, \"Not in cart\");\r\n        require(quantity > 0, \"Use removeFromCart\");\r\n        _cart[msg.sender][idx - 1].quantity = quantity;\r\n    }\r\n\r\n    function getCart(address user) external view returns (\r\n        uint256[] memory productIds_,\r\n        uint256[] memory quantities_\r\n    ) {\r\n        CartItem[] storage cart = _cart[user];\r\n        uint256 len = cart.length;\r\n        productIds_ = new uint256[](len);\r\n        quantities_ = new uint256[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            productIds_[i] = cart[i].productId;\r\n            quantities_[i] = cart[i].quantity;\r\n        }\r\n    }\r\n\r\n    function clearCart() external {\r\n        CartItem[] storage cart = _cart[msg.sender];\r\n        for (uint256 i = 0; i < cart.length; i++) {\r\n            delete _cartIndex[msg.sender][cart[i].productId];\r\n        }\r\n        delete _cart[msg.sender];\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Disputes ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function openDispute(uint256 orderId, string calldata reason) external {\r\n        Order storage o = orders[orderId];\r\n        require(\r\n            o.buyer == msg.sender || shops[o.shopId].owner == msg.sender,\r\n            \"Not party\"\r\n        );\r\n        _openDisputeInternal(orderId, msg.sender, reason);\r\n    }\r\n\r\n    function _openDisputeInternal(uint256 orderId, address opener, string memory reason) internal {\r\n        require(!disputes[orderId].resolved, \"Already resolved\");\r\n        require(disputes[orderId].openedAt == 0, \"Dispute exists\");\r\n\r\n        Order storage o = orders[orderId];\r\n        o.status    = OrderStatus.Disputed;\r\n        o.updatedAt = block.timestamp;\r\n\r\n        disputes[orderId] = Dispute({\r\n            orderId:    orderId,\r\n            opener:     opener,\r\n            reason:     reason,\r\n            resolution: \"\",\r\n            resolved:   false,\r\n            openedAt:   block.timestamp,\r\n            resolvedAt: 0\r\n        });\r\n\r\n        emit DisputeOpened(orderId, opener, reason, block.timestamp);\r\n        emit OrderStatusUpdated(orderId, OrderStatus.Disputed, block.timestamp);\r\n    }\r\n\r\n    function resolveDispute(uint256 orderId, string calldata resolution, bool refundBuyer) external onlyOwner {\r\n        Dispute storage d = disputes[orderId];\r\n        require(d.openedAt > 0, \"No dispute\");\r\n        require(!d.resolved, \"Already resolved\");\r\n\r\n        d.resolution = resolution;\r\n        d.resolved   = true;\r\n        d.resolvedAt = block.timestamp;\r\n\r\n        Order storage o = orders[orderId];\r\n        if (refundBuyer) {\r\n            // Restore stock\r\n            OrderItem[] storage items = _orderItems[orderId];\r\n            for (uint256 i = 0; i < items.length; i++) {\r\n                Product storage p = products[items[i].productId];\r\n                p.stock += items[i].quantity;\r\n                if (p.status == ProductStatus.SoldOut && p.stock > 0) {\r\n                    p.status = ProductStatus.Active;\r\n                }\r\n            }\r\n            o.status = OrderStatus.Refunded;\r\n            emit OrderRefunded(orderId, o.totalAmount, resolution, block.timestamp);\r\n        } else {\r\n            o.status = OrderStatus.Completed;\r\n        }\r\n        o.updatedAt = block.timestamp;\r\n\r\n        emit DisputeResolved(orderId, resolution, block.timestamp);\r\n        emit OrderStatusUpdated(orderId, o.status, block.timestamp);\r\n    }\r\n\r\n    // ═══════════════════════════════════════════════\r\n    // ─── Platform Stats ───\r\n    // ═══════════════════════════════════════════════\r\n\r\n    function getPlatformStats() external view returns (\r\n        uint256 totalShops_,\r\n        uint256 totalProducts_,\r\n        uint256 totalOrders_,\r\n        uint256 totalVolume_,\r\n        uint256 totalReviews_\r\n    ) {\r\n        return (\r\n            nextShopId - 1,\r\n            nextProductId - 1,\r\n            nextOrderId - 1,\r\n            totalPlatformVolume,\r\n            totalPlatformReviews\r\n        );\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}