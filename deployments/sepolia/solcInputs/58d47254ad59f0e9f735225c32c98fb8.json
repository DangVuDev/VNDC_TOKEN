{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/modules/012-reputation/IReputationBadgeSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\n/**\r\n * @title IReputationBadgeSystem\r\n * @dev Interface for reputation and badge management system\r\n */\r\ninterface IReputationBadgeSystem {\r\n    // ============ Events ============\r\n    event BadgeTypeCreated(\r\n        uint256 indexed badgeTypeId,\r\n        string name,\r\n        uint256 requiredPoints,\r\n        uint256 createdAt\r\n    );\r\n\r\n    event BadgeAwarded(\r\n        address indexed user,\r\n        uint256 indexed badgeTypeId,\r\n        uint256 awardedAt\r\n    );\r\n\r\n    event BadgeRevoked(\r\n        address indexed user,\r\n        uint256 indexed badgeTypeId,\r\n        uint256 revokedAt\r\n    );\r\n\r\n    event ReputationPointsAdded(\r\n        address indexed user,\r\n        uint256 points,\r\n        string reason,\r\n        uint256 addedAt\r\n    );\r\n\r\n    event ReputationPointsDeducted(\r\n        address indexed user,\r\n        uint256 points,\r\n        string reason,\r\n        uint256 deductedAt\r\n    );\r\n\r\n    event TierUpdated(\r\n        address indexed user,\r\n        uint256 newTier,\r\n        uint256 updatedAt\r\n    );\r\n\r\n    event AchievementUnlocked(\r\n        address indexed user,\r\n        string achievement,\r\n        uint256 unlockedAt\r\n    );\r\n\r\n    // ============ Mutations ============\r\n    /**\r\n     * @notice Create a badge type\r\n     * @param name Badge name\r\n     * @param description Badge description\r\n     * @param requiredPoints Points required to earn badge\r\n     * @param category Badge category\r\n     * @param iconURI IPFS URI for badge icon\r\n     * @return badgeTypeId ID of the badge type\r\n     */\r\n    function createBadgeType(\r\n        string calldata name,\r\n        string calldata description,\r\n        uint256 requiredPoints,\r\n        string calldata category,\r\n        string calldata iconURI\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Award badge to user\r\n     * @param user User address\r\n     * @param badgeTypeId Badge type ID\r\n     */\r\n    function awardBadge(address user, uint256 badgeTypeId) external;\r\n\r\n    /**\r\n     * @notice Revoke badge from user\r\n     * @param user User address\r\n     * @param badgeTypeId Badge type ID\r\n     */\r\n    function revokeBadge(address user, uint256 badgeTypeId) external;\r\n\r\n    /**\r\n     * @notice Add reputation points\r\n     * @param user User address\r\n     * @param points Points to add\r\n     * @param reason Reason for points\r\n     */\r\n    function addReputationPoints(\r\n        address user,\r\n        uint256 points,\r\n        string calldata reason\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Deduct reputation points\r\n     * @param user User address\r\n     * @param points Points to deduct\r\n     * @param reason Reason for deduction\r\n     */\r\n    function deductReputationPoints(\r\n        address user,\r\n        uint256 points,\r\n        string calldata reason\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Unlock achievement\r\n     * @param user User address\r\n     * @param achievement Achievement name\r\n     */\r\n    function unlockAchievement(address user, string calldata achievement) external;\r\n\r\n    /**\r\n     * @notice Authorize a badge issuer\r\n     * @param issuer Issuer address\r\n     */\r\n    function authorizeBadgeIssuer(address issuer) external;\r\n\r\n    /**\r\n     * @notice Revoke badge issuer authorization\r\n     * @param issuer Issuer address\r\n     */\r\n    function revokeBadgeIssuer(address issuer) external;\r\n\r\n    /**\r\n     * @notice Authorize points editor\r\n     * @param editor Editor address\r\n     */\r\n    function authorizePointsEditor(address editor) external;\r\n\r\n    /**\r\n     * @notice Revoke points editor authorization\r\n     * @param editor Editor address\r\n     */\r\n    function revokePointsEditor(address editor) external;\r\n\r\n    // ============ Queries ============\r\n    /**\r\n     * @notice Get user reputation points\r\n     * @param user User address\r\n     */\r\n    function getUserReputationPoints(address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Get user tier level\r\n     * @param user User address\r\n     */\r\n    function getUserTier(address user)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Get user badges\r\n     * @param user User address\r\n     */\r\n    function getUserBadges(address user)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @notice Check if user has badge\r\n     * @param user User address\r\n     * @param badgeTypeId Badge type ID\r\n     */\r\n    function hasBadge(address user, uint256 badgeTypeId)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Get badge type information\r\n     * @param badgeTypeId Badge type ID\r\n     */\r\n    function getBadgeTypeInfo(uint256 badgeTypeId)\r\n        external\r\n        view\r\n        returns (\r\n            string memory name,\r\n            string memory description,\r\n            uint256 requiredPoints,\r\n            string memory category,\r\n            string memory iconURI,\r\n            uint256 totalAwarded\r\n        );\r\n\r\n    /**\r\n     * @notice Get user achievements\r\n     * @param user User address\r\n     */\r\n    function getUserAchievements(address user)\r\n        external\r\n        view\r\n        returns (string[] memory);\r\n\r\n    /**\r\n     * @notice Check if user has achievement\r\n     * @param user User address\r\n     * @param achievement Achievement name\r\n     */\r\n    function hasAchievement(address user, string calldata achievement)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Get reputation history for user\r\n     * @param user User address\r\n     */\r\n    function getReputationHistory(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory points,\r\n            string[] memory reasons,\r\n            uint256[] memory timestamps\r\n        );\r\n\r\n    /**\r\n     * @notice Get badge history\r\n     * @param user User address\r\n     */\r\n    function getBadgeHistory(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory badgeTypeIds,\r\n            uint256[] memory awardedAt,\r\n            bool[] memory isActive\r\n        );\r\n\r\n    /**\r\n     * @notice Get total badge types\r\n     */\r\n    function getTotalBadgeTypes() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get total users with reputation\r\n     */\r\n    function getTotalUsersWithReputation() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Get leaderboard (top users by reputation)\r\n     * @param limit Number of users to return\r\n     */\r\n    function getLeaderboard(uint256 limit)\r\n        external\r\n        view\r\n        returns (address[] memory users, uint256[] memory points);\r\n\r\n    /**\r\n     * @notice Get tier information\r\n     * @param tier Tier level\r\n     */\r\n    function getTierInfo(uint256 tier)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 minPoints,\r\n            uint256 maxPoints,\r\n            string memory name\r\n        );\r\n\r\n    /**\r\n     * @notice Check if address is badge issuer\r\n     * @param issuer Issuer address\r\n     */\r\n    function isBadgeIssuer(address issuer)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /**\r\n     * @notice Check if address is points editor\r\n     * @param editor Editor address\r\n     */\r\n    function isPointsEditor(address editor)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n"
    },
    "contracts/modules/012-reputation/ReputationBadgeSystem.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {IReputationBadgeSystem} from \"./IReputationBadgeSystem.sol\";\r\n\r\n/**\r\n * @title ReputationBadgeSystem\r\n * @dev Manages user reputation points and badges/achievements\r\n */\r\ncontract ReputationBadgeSystem is Ownable, IReputationBadgeSystem {\r\n    // ============ Data Structures ============\r\n    struct BadgeType {\r\n        string name;\r\n        string description;\r\n        uint256 requiredPoints;\r\n        string category;\r\n        string iconURI;\r\n        uint256 totalAwarded;\r\n    }\r\n\r\n    struct ReputationRecord {\r\n        uint256 points;\r\n        string reason;\r\n        uint256 timestamp;\r\n        bool isAddition;\r\n    }\r\n\r\n    struct BadgeRecord {\r\n        uint256 badgeTypeId;\r\n        uint256 awardedAt;\r\n        bool isActive;\r\n    }\r\n\r\n    struct TierInfo {\r\n        uint256 minPoints;\r\n        uint256 maxPoints;\r\n        string name;\r\n    }\r\n\r\n    // ============ State Variables ============\r\n    uint256 private badgeTypeCounter;\r\n    \r\n    mapping(address => uint256) private userReputationPoints;\r\n    mapping(address => uint256) private userTier;\r\n    mapping(address => uint256[]) private userBadges;\r\n    mapping(address => mapping(uint256 => bool)) private userHasBadge;\r\n    mapping(uint256 => BadgeType) private badgeTypes;\r\n    mapping(address => ReputationRecord[]) private reputationHistory;\r\n    mapping(address => BadgeRecord[]) private badgeHistory;\r\n    mapping(address => mapping(string => bool)) private userAchievements;\r\n    mapping(address => string[]) private userAchievementsList;\r\n    mapping(address => bool) private authorizedBadgeIssuers;\r\n    mapping(address => bool) private authorizedPointsEditors;\r\n\r\n    // Tier system\r\n    mapping(uint256 => TierInfo) private tiers;\r\n\r\n    // Leaderboard tracking\r\n    address[] private usersWithReputation;\r\n    mapping(address => bool) private isTrackedUser;\r\n\r\n    // Statistics\r\n    uint256 private totalBadgeTypes;\r\n\r\n    // ============ Modifiers ============\r\n    modifier onlyBadgeIssuer() {\r\n        require(\r\n            authorizedBadgeIssuers[msg.sender] || msg.sender == owner(),\r\n            \"ReputationBadgeSystem: Not authorized badge issuer\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyPointsEditor() {\r\n        require(\r\n            authorizedPointsEditors[msg.sender] || msg.sender == owner(),\r\n            \"ReputationBadgeSystem: Not authorized points editor\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier badgeTypeExists(uint256 badgeTypeId) {\r\n        require(\r\n            badgeTypeId > 0 && badgeTypeId < badgeTypeCounter,\r\n            \"ReputationBadgeSystem: Badge type does not exist\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ============ Constructor ============\r\n    constructor() Ownable(msg.sender) {\r\n        badgeTypeCounter = 1;\r\n        totalBadgeTypes = 0;\r\n\r\n        // Initialize tier system\r\n        // Tier 1: 0-999 points (Bronze)\r\n        tiers[1] = TierInfo({minPoints: 0, maxPoints: 999, name: \"Bronze\"});\r\n        // Tier 2: 1000-4999 points (Silver)\r\n        tiers[2] = TierInfo({minPoints: 1000, maxPoints: 4999, name: \"Silver\"});\r\n        // Tier 3: 5000-9999 points (Gold)\r\n        tiers[3] = TierInfo({minPoints: 5000, maxPoints: 9999, name: \"Gold\"});\r\n        // Tier 4: 10000+ points (Platinum)\r\n        tiers[4] = TierInfo({minPoints: 10000, maxPoints: type(uint256).max, name: \"Platinum\"});\r\n\r\n        // Authorize deployer\r\n        authorizedBadgeIssuers[msg.sender] = true;\r\n        authorizedPointsEditors[msg.sender] = true;\r\n    }\r\n\r\n    // ============ Core Functions ============\r\n    /**\r\n     * @notice Create a badge type\r\n     */\r\n    function createBadgeType(\r\n        string calldata name,\r\n        string calldata description,\r\n        uint256 requiredPoints,\r\n        string calldata category,\r\n        string calldata iconURI\r\n    ) external onlyOwner returns (uint256) {\r\n        require(bytes(name).length > 0, \"ReputationBadgeSystem: Name required\");\r\n        require(requiredPoints >= 0, \"ReputationBadgeSystem: Points must be valid\");\r\n\r\n        uint256 badgeTypeId = badgeTypeCounter++;\r\n\r\n        badgeTypes[badgeTypeId] = BadgeType({\r\n            name: name,\r\n            description: description,\r\n            requiredPoints: requiredPoints,\r\n            category: category,\r\n            iconURI: iconURI,\r\n            totalAwarded: 0\r\n        });\r\n\r\n        totalBadgeTypes++;\r\n\r\n        emit BadgeTypeCreated(badgeTypeId, name, requiredPoints, block.timestamp);\r\n\r\n        return badgeTypeId;\r\n    }\r\n\r\n    /**\r\n     * @notice Award badge to user\r\n     */\r\n    function awardBadge(address user, uint256 badgeTypeId)\r\n        external\r\n        onlyBadgeIssuer\r\n        badgeTypeExists(badgeTypeId)\r\n    {\r\n        require(user != address(0), \"ReputationBadgeSystem: Invalid user address\");\r\n        require(!userHasBadge[user][badgeTypeId], \"ReputationBadgeSystem: Already has badge\");\r\n\r\n        userHasBadge[user][badgeTypeId] = true;\r\n        userBadges[user].push(badgeTypeId);\r\n        badgeTypes[badgeTypeId].totalAwarded++;\r\n\r\n        // Add to badge history\r\n        badgeHistory[user].push(BadgeRecord({\r\n            badgeTypeId: badgeTypeId,\r\n            awardedAt: block.timestamp,\r\n            isActive: true\r\n        }));\r\n\r\n        emit BadgeAwarded(user, badgeTypeId, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke badge from user\r\n     */\r\n    function revokeBadge(address user, uint256 badgeTypeId)\r\n        external\r\n        onlyBadgeIssuer\r\n        badgeTypeExists(badgeTypeId)\r\n    {\r\n        require(user != address(0), \"ReputationBadgeSystem: Invalid user address\");\r\n        require(userHasBadge[user][badgeTypeId], \"ReputationBadgeSystem: Does not have badge\");\r\n\r\n        userHasBadge[user][badgeTypeId] = false;\r\n\r\n        // Mark in badge history\r\n        for (uint256 i = 0; i < badgeHistory[user].length; i++) {\r\n            if (badgeHistory[user][i].badgeTypeId == badgeTypeId && badgeHistory[user][i].isActive) {\r\n                badgeHistory[user][i].isActive = false;\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit BadgeRevoked(user, badgeTypeId, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Add reputation points\r\n     */\r\n    function addReputationPoints(\r\n        address user,\r\n        uint256 points,\r\n        string calldata reason\r\n    ) external onlyPointsEditor {\r\n        require(user != address(0), \"ReputationBadgeSystem: Invalid user address\");\r\n        require(points > 0, \"ReputationBadgeSystem: Points must be greater than 0\");\r\n\r\n        userReputationPoints[user] += points;\r\n\r\n        // Track in history\r\n        reputationHistory[user].push(ReputationRecord({\r\n            points: points,\r\n            reason: reason,\r\n            timestamp: block.timestamp,\r\n            isAddition: true\r\n        }));\r\n\r\n        // Track user in leaderboard\r\n        if (!isTrackedUser[user]) {\r\n            usersWithReputation.push(user);\r\n            isTrackedUser[user] = true;\r\n        }\r\n\r\n        // Update tier\r\n        _updateUserTier(user);\r\n\r\n        emit ReputationPointsAdded(user, points, reason, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Deduct reputation points\r\n     */\r\n    function deductReputationPoints(\r\n        address user,\r\n        uint256 points,\r\n        string calldata reason\r\n    ) external onlyPointsEditor {\r\n        require(user != address(0), \"ReputationBadgeSystem: Invalid user address\");\r\n        require(points > 0, \"ReputationBadgeSystem: Points must be greater than 0\");\r\n        require(\r\n            userReputationPoints[user] >= points,\r\n            \"ReputationBadgeSystem: Insufficient reputation points\"\r\n        );\r\n\r\n        userReputationPoints[user] -= points;\r\n\r\n        // Track in history\r\n        reputationHistory[user].push(ReputationRecord({\r\n            points: points,\r\n            reason: reason,\r\n            timestamp: block.timestamp,\r\n            isAddition: false\r\n        }));\r\n\r\n        // Update tier\r\n        _updateUserTier(user);\r\n\r\n        emit ReputationPointsDeducted(user, points, reason, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Unlock achievement\r\n     */\r\n    function unlockAchievement(address user, string calldata achievement)\r\n        external\r\n        onlyPointsEditor\r\n    {\r\n        require(user != address(0), \"ReputationBadgeSystem: Invalid user address\");\r\n        require(!userAchievements[user][achievement], \"ReputationBadgeSystem: Already unlocked\");\r\n\r\n        userAchievements[user][achievement] = true;\r\n        userAchievementsList[user].push(achievement);\r\n\r\n        emit AchievementUnlocked(user, achievement, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Authorize badge issuer\r\n     */\r\n    function authorizeBadgeIssuer(address issuer) external onlyOwner {\r\n        require(issuer != address(0), \"ReputationBadgeSystem: Invalid address\");\r\n        authorizedBadgeIssuers[issuer] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke badge issuer authorization\r\n     */\r\n    function revokeBadgeIssuer(address issuer) external onlyOwner {\r\n        require(issuer != address(0), \"ReputationBadgeSystem: Invalid address\");\r\n        authorizedBadgeIssuers[issuer] = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Authorize points editor\r\n     */\r\n    function authorizePointsEditor(address editor) external onlyOwner {\r\n        require(editor != address(0), \"ReputationBadgeSystem: Invalid address\");\r\n        authorizedPointsEditors[editor] = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke points editor authorization\r\n     */\r\n    function revokePointsEditor(address editor) external onlyOwner {\r\n        require(editor != address(0), \"ReputationBadgeSystem: Invalid address\");\r\n        authorizedPointsEditors[editor] = false;\r\n    }\r\n\r\n    // ============ Query Functions ============\r\n    /**\r\n     * @notice Get user reputation points\r\n     */\r\n    function getUserReputationPoints(address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return userReputationPoints[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Get user tier\r\n     */\r\n    function getUserTier(address user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return userTier[user] == 0 ? 1 : userTier[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Get user badges\r\n     */\r\n    function getUserBadges(address user)\r\n        external\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        return userBadges[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Check if user has badge\r\n     */\r\n    function hasBadge(address user, uint256 badgeTypeId)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return userHasBadge[user][badgeTypeId];\r\n    }\r\n\r\n    /**\r\n     * @notice Get badge type information\r\n     */\r\n    function getBadgeTypeInfo(uint256 badgeTypeId)\r\n        external\r\n        view\r\n        badgeTypeExists(badgeTypeId)\r\n        returns (\r\n            string memory name,\r\n            string memory description,\r\n            uint256 requiredPoints,\r\n            string memory category,\r\n            string memory iconURI,\r\n            uint256 totalAwarded\r\n        )\r\n    {\r\n        BadgeType memory badge = badgeTypes[badgeTypeId];\r\n        return (\r\n            badge.name,\r\n            badge.description,\r\n            badge.requiredPoints,\r\n            badge.category,\r\n            badge.iconURI,\r\n            badge.totalAwarded\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get user achievements\r\n     */\r\n    function getUserAchievements(address user)\r\n        external\r\n        view\r\n        returns (string[] memory)\r\n    {\r\n        return userAchievementsList[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Check if user has achievement\r\n     */\r\n    function hasAchievement(address user, string calldata achievement)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return userAchievements[user][achievement];\r\n    }\r\n\r\n    /**\r\n     * @notice Get reputation history\r\n     */\r\n    function getReputationHistory(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory points,\r\n            string[] memory reasons,\r\n            uint256[] memory timestamps\r\n        )\r\n    {\r\n        ReputationRecord[] memory history = reputationHistory[user];\r\n        uint256 length = history.length;\r\n\r\n        uint256[] memory pointsArray = new uint256[](length);\r\n        string[] memory reasonsArray = new string[](length);\r\n        uint256[] memory timestampsArray = new uint256[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            pointsArray[i] = history[i].points;\r\n            reasonsArray[i] = history[i].reason;\r\n            timestampsArray[i] = history[i].timestamp;\r\n        }\r\n\r\n        return (pointsArray, reasonsArray, timestampsArray);\r\n    }\r\n\r\n    /**\r\n     * @notice Get badge history\r\n     */\r\n    function getBadgeHistory(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory badgeTypeIds,\r\n            uint256[] memory awardedAt,\r\n            bool[] memory isActive\r\n        )\r\n    {\r\n        BadgeRecord[] memory history = badgeHistory[user];\r\n        uint256 length = history.length;\r\n\r\n        uint256[] memory badgeIdsArray = new uint256[](length);\r\n        uint256[] memory awardedAtArray = new uint256[](length);\r\n        bool[] memory isActiveArray = new bool[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            badgeIdsArray[i] = history[i].badgeTypeId;\r\n            awardedAtArray[i] = history[i].awardedAt;\r\n            isActiveArray[i] = history[i].isActive;\r\n        }\r\n\r\n        return (badgeIdsArray, awardedAtArray, isActiveArray);\r\n    }\r\n\r\n    /**\r\n     * @notice Get total badge types\r\n     */\r\n    function getTotalBadgeTypes() external view returns (uint256) {\r\n        return totalBadgeTypes;\r\n    }\r\n\r\n    /**\r\n     * @notice Get total users with reputation\r\n     */\r\n    function getTotalUsersWithReputation() external view returns (uint256) {\r\n        return usersWithReputation.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Get leaderboard\r\n     */\r\n    function getLeaderboard(uint256 limit)\r\n        external\r\n        view\r\n        returns (address[] memory users, uint256[] memory points)\r\n    {\r\n        uint256 count = limit < usersWithReputation.length ? limit : usersWithReputation.length;\r\n        \r\n        address[] memory topUsers = new address[](count);\r\n        uint256[] memory topPoints = new uint256[](count);\r\n\r\n        // Simple selection sort (for small limits)\r\n        address[] memory sorted = usersWithReputation;\r\n        \r\n        uint256 placed = 0;\r\n        for (uint256 i = 0; i < sorted.length && placed < count; i++) {\r\n            uint256 maxPoints = 0;\r\n            uint256 maxIdx = 0;\r\n            \r\n            for (uint256 j = 0; j < sorted.length; j++) {\r\n                if (userReputationPoints[sorted[j]] > maxPoints) {\r\n                    bool alreadyAdded = false;\r\n                    for (uint256 k = 0; k < placed; k++) {\r\n                        if (topUsers[k] == sorted[j]) {\r\n                            alreadyAdded = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!alreadyAdded) {\r\n                        maxPoints = userReputationPoints[sorted[j]];\r\n                        maxIdx = j;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            if (maxPoints > 0) {\r\n                topUsers[placed] = sorted[maxIdx];\r\n                topPoints[placed] = maxPoints;\r\n                placed++;\r\n            }\r\n        }\r\n\r\n        return (topUsers, topPoints);\r\n    }\r\n\r\n    /**\r\n     * @notice Get tier information\r\n     */\r\n    function getTierInfo(uint256 tier)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 minPoints,\r\n            uint256 maxPoints,\r\n            string memory name\r\n        )\r\n    {\r\n        require(tier >= 1 && tier <= 4, \"ReputationBadgeSystem: Invalid tier\");\r\n        TierInfo memory tierData = tiers[tier];\r\n        return (tierData.minPoints, tierData.maxPoints, tierData.name);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if badge issuer\r\n     */\r\n    function isBadgeIssuer(address issuer)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return authorizedBadgeIssuers[issuer];\r\n    }\r\n\r\n    /**\r\n     * @notice Check if points editor\r\n     */\r\n    function isPointsEditor(address editor)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return authorizedPointsEditors[editor];\r\n    }\r\n\r\n    // ============ Internal Helper Functions ============\r\n    /**\r\n     * @notice Update user tier based on reputation points\r\n     */\r\n    function _updateUserTier(address user) internal {\r\n        uint256 points = userReputationPoints[user];\r\n\r\n        if (points < 1000) {\r\n            userTier[user] = 1;\r\n        } else if (points < 5000) {\r\n            userTier[user] = 2;\r\n        } else if (points < 10000) {\r\n            userTier[user] = 3;\r\n        } else {\r\n            userTier[user] = 4;\r\n        }\r\n\r\n        emit TierUpdated(user, userTier[user], block.timestamp);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}